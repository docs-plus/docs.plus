name: 'Discord: repo activity'

on:
  push:
    branches: ['**']

jobs:
  notify:
    runs-on: ubuntu-latest
    steps:
      - name: Build commit summary (for push)
        id: build
        env:
          EVENT_JSON: ${{ toJSON(github.event) }}
        run: |
          COUNT=$(jq -r '.commits | length' <<< "$EVENT_JSON")
          REF=$(jq -r '.ref' <<< "$EVENT_JSON" | sed 's|refs/heads/||')
          COMPARE=$(jq -r '.compare' <<< "$EVENT_JSON")

          # Check if this is a build trigger commit (skip notification)
          # Use jq for comparison to avoid shell escaping issues with special chars
          SKIP_NOTIFICATION="false"
          if [ "$COUNT" -eq 1 ]; then
            FIRST_MSG=$(jq -r '.commits[0].message // "" | split("\n")[0]' <<< "$EVENT_JSON")
            if [ "$FIRST_MSG" = "build front back" ]; then
              SKIP_NOTIFICATION="true"
              echo "‚è≠Ô∏è Skipping Discord notification (build trigger commit)"
            fi
          fi

          # Write commits directly to file (avoids shell interpolation issues)
          REPO_URL="https://github.com/${{ github.repository }}"
          jq -r --arg repo "$REPO_URL" '.commits | to_entries[] |
            (1 + .key | tostring) + ". " +
            (.value.message | gsub("\\r?\\n"; " ") | gsub("[\\(\\)\\[\\]`]"; "")) +
            " [" + .value.id[0:7] + "](" + $repo + "/commit/" + .value.id + ") by " + .value.author.name' <<< "$EVENT_JSON" > /tmp/commits.txt

          {
            echo "COUNT=$COUNT"
            echo "REF=$REF"
            echo "COMPARE=$COMPARE"
            echo "SKIP_NOTIFICATION=$SKIP_NOTIFICATION"
          } >> "$GITHUB_ENV"

      - name: Post to Discord (smart split)
        if: env.SKIP_NOTIFICATION != 'true'
        run: |
          HEADER="üöÄ **Push Event**
          üì¶ Repository: \`${{ github.repository }}\`
          üë§ Author: \`${{ github.actor }}\`
          üåø Branch: \`${{ env.REF }}\`
          üìù Commits: \`${{ env.COUNT }}\`
          üîó [View Diff](${{ env.COMPARE }})

          **Commit List:**
          "

          MAX_LEN=1900  # Leave buffer for safety

          # Split commits into chunks
          CURRENT_CHUNK=""
          CHUNK_NUM=1

          while IFS= read -r line || [ -n "$line" ]; do
            # Skip empty lines
            [ -z "$line" ] && continue

            TEST_MSG="${HEADER}${CURRENT_CHUNK}${line}"$'\n'

            if [ ${#TEST_MSG} -gt $MAX_LEN ] && [ -n "$CURRENT_CHUNK" ]; then
              # Send current chunk
              if [ $CHUNK_NUM -eq 1 ]; then
                MESSAGE="${HEADER}${CURRENT_CHUNK}"
              else
                MESSAGE="${CURRENT_CHUNK}"
              fi

              curl -H "Content-Type: application/json" \
                   -d "{\"content\": $(printf '%s' "$MESSAGE" | jq -Rs .), \"flags\": 4}" \
                   "${{ secrets.DISCORD_WEBHOOK }}"

              sleep 1  # Rate limit protection
              CHUNK_NUM=$((CHUNK_NUM + 1))
              CURRENT_CHUNK="${line}"$'\n'
            else
              CURRENT_CHUNK="${CURRENT_CHUNK}${line}"$'\n'
            fi
          done < /tmp/commits.txt

          # Send final chunk
          if [ -n "$CURRENT_CHUNK" ]; then
            if [ $CHUNK_NUM -eq 1 ]; then
              MESSAGE="${HEADER}${CURRENT_CHUNK}"
            else
              MESSAGE="${CURRENT_CHUNK}"
            fi

            curl -H "Content-Type: application/json" \
                 -d "{\"content\": $(printf '%s' "$MESSAGE" | jq -Rs .), \"flags\": 4}" \
                 "${{ secrets.DISCORD_WEBHOOK }}"
          fi
